<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="司大伟">
  <meta name="dcterms.date" content="2016-06-25">
  <title>Python编码规范</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">code{white-space: pre;}</style>

<!-- For syntax highlighting -->
  <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

  <link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
  <h1 class="title">Python编码规范</h1>
  <h2 class="author">司大伟</h2>
  <h3 class="date">2016-06-25</h3>
</section>

<section><section id="概述" class="titleslide slide level1"><h1>概述</h1></section><section id="什么是pep8" class="slide level2">
<h1>什么是PEP8</h1>
<p>PEP = Python Enhancement Proposal</p>
<p>PEP8 = Style Guide for Python Code</p>
</section><section id="为什么要代码规范" class="slide level2">
<h1>为什么要代码规范</h1>
<p>Guido:</p>
<p><strong>Code is read much more often than it is written.</strong></p>
</section><section class="slide level2">

<h3 id="什么时候不必遵守规范">什么时候不必遵守规范</h3>
<ul>
<li class="fragment">使得代码可读性变差</li>
<li class="fragment">破坏当前代码风格的连续性(比如历史原因)</li>
<li class="fragment">当代码需要保持向后兼容性</li>
</ul>
</section></section>
<section><section id="代码布局" class="titleslide slide level1"><h1>代码布局</h1></section><section id="缩进" class="slide level2">
<h1>缩进</h1>
<ul>
<li class="fragment">使用4个空格作为一级缩进</li>
<li class="fragment">不要混用Tab和空格</li>
<li class="fragment">设置编辑器将Tab转为空格</li>
</ul>
</section><section class="slide level2">

<h3 id="断行的对齐">断行的对齐</h3>
<p>被括号括起来的连续的长行, 比如函数定义/调用, 列表, 字典, 在换行时有两种对齐风格.</p>
<p>一种是垂直对齐.</p>
<pre class="python"><code># 以括号为界, 垂直对齐.
foo = long_function_name(var_one, var_two,
                         var_three, var_four)
</code></pre>
<div class="fragment">
<p>一种是悬挂式缩进(hanging indent)</p>
<pre class="python"><code># 从括号起始就换行, 比正常的缩进多缩进一点以示区分.
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)</code></pre>
</div>
</section><section class="slide level2">

<h3 id="不好的风格">不好的风格</h3>
<pre class="python"><code># 没有垂直对齐, 第一行参数就显得不突出.
foo = long_function_name(var_one, var_two,
    var_three, var_four)

# 和正常的函数体语句缩进一样, 不好区分.
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)</code></pre>
</section><section class="slide level2">

<h3 id="if语句的缩进">IF语句的缩进</h3>
<p>当if语句后面的条件判断需要折行时, if占2个字符, 加上空格和左括号, 总共刚好是4个字符. 也就是说, 这时候如果是垂直对齐的话, 就和下面的语句缩进一样了, 例如:</p>
<pre class="python"><code># No extra indentation.
if (this_is_one_thing and
    that_is_another_thing):
    do_something()</code></pre>
</section><section class="slide level2">

<h3 id="if语句的缩进-1">IF语句的缩进</h3>
<pre class="python"><code># 添加一行注释, 这样在语法高亮的编辑器中会显得有所区别
# 但是pycharm中的pep8检测还是会提示
if (this_is_one_thing and
    that_is_another_thing):
    # Since both conditions are true, we can frobnicate.
    do_something()

# 增加额外的缩进.
if (this_is_one_thing
        and that_is_another_thing):
    do_something()</code></pre>
</section><section class="slide level2">

<h3 id="右括号的位置">右括号的位置</h3>
<p>多行语句中右括号(包括 圆括号,方括号,花括号)的位置也有两种情况</p>
<pre class="python"><code># 和第一个非空字符对齐
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    &#39;a&#39;, &#39;b&#39;, &#39;c&#39;,
    &#39;d&#39;, &#39;e&#39;, &#39;f&#39;,
    )</code></pre>
<div class="fragment">
<pre class="python"><code># 置于行首
my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    &#39;a&#39;, &#39;b&#39;, &#39;c&#39;,
    &#39;d&#39;, &#39;e&#39;, &#39;f&#39;,
)</code></pre>
</div>
</section><section class="slide level2">

<h3 id="二元运算符的位置">二元运算符的位置</h3>
<pre class="python"><code># No: 运算符和运算对象离得太远了
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)</code></pre>
<pre class="python"><code># Yes: 运算符和运算对象很容易匹配
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)</code></pre>
</section><section id="空行" class="slide level2">
<h1>空行</h1>
<ul>
<li class="fragment">顶层的函数和类定义之间用两个空行隔开</li>
<li class="fragment">类中的方法定义之间用一个空行隔开</li>
<li class="fragment">使用额外的空行来区分某组相关联的函数(保守使用)</li>
<li class="fragment">在函数中也可以用空行分隔不同的逻辑段(保守使用)</li>
<li class="fragment">连续的单行语句之间的空行可以省略</li>
</ul>
</section><section id="源文件编码" class="slide level2">
<h1>源文件编码</h1>
<ul>
<li class="fragment">Python2中默认的编码是ASCII</li>
<li class="fragment">Python3中默认的编码是UTF-8</li>
<li class="fragment">使用默认编码的无需编码声明</li>
</ul>
</section><section id="模块导入" class="slide level2">
<h1>模块导入</h1>
<p>import语句一般都要独占一行</p>
<pre class="python"><code>Yes: import os
     import sys

No:  import sys, os</code></pre>
<p>但是下面这种也可以接受</p>
<pre class="python"><code>from subprocess import Popen, PIPE</code></pre>
</section><section class="slide level2">

<h3 id="import语句的顺序">import语句的顺序</h3>
<p>import 语句一般总是在文件的上方, 接在模块注释和Docstring的后面, 在模块全局变量和常量之前.</p>
<p>import 语句应该遵从下面的顺序:</p>
<ol type="1">
<li class="fragment">标准库</li>
<li class="fragment">第三方库</li>
<li class="fragment">当前应用/库</li>
</ol>
</section><section class="slide level2">

<h3 id="绝对路径import">绝对路径import</h3>
<p>推荐使用绝对路径的import语句, 因为可读性更好.</p>
<p>当import出现问题时, 绝对路径可以提供更多的错误信息</p>
<pre class="python"><code>import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example</code></pre>
</section><section class="slide level2">

<h3 id="显式相对路径import">显式相对路径import</h3>
<p>当情况比较复杂时, <em>显式</em> 相对路径import也是可以的.</p>
<pre class="python"><code>from . import sibling
from .sibling import example</code></pre>
<p>避免使用隐式相对路径import, 这种方式在Python3中已经被淘汰.</p>
<!-- 隐式import的例子 -->
</section><section class="slide level2">

<h3 id="从模块中import类">从模块中import类</h3>
<p>可以直接import类</p>
<pre class="python"><code>from myclass import MyClass
from foo.bar.yourclass import YourClass</code></pre>
<p>如果要引入的类名和本地名称冲突, 也可以这样:</p>
<pre class="python"><code>import myclass
import foo.bar.yourclass

obj = myclass.MyClass()</code></pre>
</section><section class="slide level2">

<h3 id="避免使用import">避免使用import *</h3>
<p>尽量避免使用import *语句, 这样会造成本地命名空间不清晰, 对阅读代码以及一些自动化处理工具都会造成困扰.</p>
<p>只有一种例外的情况:</p>
<p><em>当需要把内部接口重新发布为外部接口</em></p>
</section><section id="module中的-__name__" class="slide level2">
<h1>module中的 <em><code>__name__</code></em></h1>
<p>模块级别的特殊名称, 即以两个下划线开始和结束的名称如 <code>__all__</code> , <code>__author__</code> , <code>__version__</code> 等. 位置应该:</p>
<ul>
<li class="fragment">置于docstring之后,</li>
<li class="fragment">import语句之前,</li>
<li class="fragment">除了 from <code>__future__</code> import xx</li>
</ul>
</section><section class="slide level2">

<h3 id="举例">举例</h3>
<pre class="python"><code>&quot;&quot;&quot;This is the example module.

This module does stuff.
&quot;&quot;&quot;

from __future__ import barry_as_FLUFL

__all__ = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
__version__ = &#39;0.1&#39;
__author__ = &#39;Cardinal Biggles&#39;

import os
import sys</code></pre>
</section></section>
<section><section id="空白" class="titleslide slide level1"><h1>空白</h1></section><section id="不要加空格的地方" class="slide level2">
<h1>不要加空格的地方</h1>
<p>以下几种情况应该避免使用无关的空格</p>
</section><section class="slide level2">

<p>括号内部两边紧挨着括号的地方不要有空格</p>
<pre class="python"><code>Yes: spam(ham[1], {eggs: 2})
No:  spam( ham[ 1 ], { eggs: 2 } )</code></pre>
</section><section class="slide level2">

<p>冒号, 逗号, 分号的前面不要有空格</p>
<pre class="python"><code>Yes: if x == 4: print x, y; x, y = y, x
No:  if x == 4 : print x , y ; x , y = y , x</code></pre>
</section><section class="slide level2">

<p>切片语句中的冒号</p>
<p>切片语句中, 冒号的作用类似于二元运算符, 在某些情况下可以在两边有对等的空格</p>
<pre class="python"><code>ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[lower:upper], ham[lower:upper:], ham[lower::step]
ham[lower+offset : upper+offset]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
ham[lower + offset : upper + offset]</code></pre>
</section><section class="slide level2">

<p>紧跟在函数调用后面的括号</p>
<pre class="python"><code>Yes: spam(1)
No:  spam (1)</code></pre>
</section><section class="slide level2">

<p>紧跟在索引或切片后面的括号</p>
<pre class="python"><code>Yes: dct[&#39;key&#39;] = lst[index]
No:  dct [&#39;key&#39;] = lst [index]</code></pre>
</section><section class="slide level2">

<p>不要为了对齐在运算符两边添加多余的空格</p>
<pre class="python"><code># Yes:
x = 1
y = 2
long_variable = 3

# No:
x             = 1
y             = 2
long_variable = 3</code></pre>
</section><section id="其它建议" class="slide level2">
<h1>其它建议</h1>
</section><section class="slide level2">

<h3 id="避免行末拖尾的空格">避免行末拖尾的空格</h3>
<ul>
<li class="fragment">避免在任何地方出现拖尾的空格, 因为编辑器中这些空格一般都不可见, 可能会导致困扰.</li>
<li class="fragment">例如如果一个反斜杠后面跟有空格, 则这个反斜杠就起不到续行的作用.</li>
<li class="fragment">有的编辑器(包括PyCharm)会在保存文件时自动去除这些空格.</li>
</ul>
</section><section class="slide level2">

<h3 id="二元操作符">二元操作符</h3>
<p>总是在二元操作符两边都加一个空格. 包括:</p>
<ul>
<li class="fragment">赋值符: <code>=</code></li>
<li class="fragment">增量赋值: <code>+= , -=</code> 等</li>
<li class="fragment">比较符: <code>== , &lt; , &gt; , != , &lt;&gt; , &lt;= , &gt;= , in , not in , is , is not</code></li>
<li class="fragment">布尔操作: <code>and , or , not</code></li>
</ul>
</section><section class="slide level2">

<p>如果涉及到多个优先级的操作符, 可以考虑在较低优先级的操作符两边加空格, 省略高优先级操作符两边的空格.</p>
<p>YES:</p>
<pre class="python"><code>i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)</code></pre>
<p>NO:</p>
<pre class="python"><code>i=i+1
submitted +=1
# 以下情况实际也是可以接受的, 例如
# pycharm自动格式化的结果就是在运算符两边统一加空格
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)</code></pre>
</section><section class="slide level2">

<p>在定义默认参数值的时候不要在 <code>=</code> 两边加空格.</p>
<p>YES:</p>
<pre class="python"><code>def complex(real, imag=0.0):
    return magic(r=real, i=imag)</code></pre>
<p>NO:</p>
<pre class="python"><code>def complex(real, imag = 0.0):
    return magic(r = real, i = imag)</code></pre>
</section><section class="slide level2">

<p>不建议把多条语句放在同一行</p>
<p>YES:</p>
<pre class="python"><code>if foo == &#39;blah&#39;:
    do_blah_thing()
do_one()
do_two()
do_three()</code></pre>
<p>NO:</p>
<pre class="python"><code>if foo == &#39;blah&#39;: do_blah_thing()
do_one(); do_two(); do_three()</code></pre>
</section><section class="slide level2">

<p>偶尔有些情况下, if/for/while/ 语句非常短, 放在一行是可以接受的(虽然不建议), 例如</p>
<pre class="python"><code># pycharm这种情况会提示, 但是自动格式化不会修改
if foo == &#39;blah&#39;: do_blah_thing()</code></pre>
<p>但是在有多个子句时绝对不要这样做!</p>
<pre class="python"><code>if foo == &#39;blah&#39;: do_blah_thing()
else: do_non_blah_thing()

try: something()
finally: cleanup()

do_one(); do_two(); do_three(long, argument,
                             list, like, this)

if foo == &#39;blah&#39;: one(); two(); three()</code></pre>
</section></section>
<section><section id="注释" class="titleslide slide level1"><h1>注释</h1></section><section id="注意事项" class="slide level2">
<h1>注意事项</h1>
<ul>
<li class="fragment">与代码矛盾的注释不如没有, 请记得及时同步更新注释</li>
</ul>
<div class="fragment">
<p>以下建议主要针对英语:</p>
<ul>
<li class="fragment">最好把注释写成完整的句子, 所以请注意句首大小写(除了该词是一个标识符)</li>
<li class="fragment">如果注释很短, 可以忽略句号, 但是如果包含多个句子, 则每句都应该以句号结尾</li>
<li class="fragment">请遵从英文写作指南</li>
</ul>
</div>
<div class="fragment">
<p>但是, 最后一个建议是...</p>
<ul>
<li class="fragment">非英语国的coder请使用English写注释, 除非120%确定该代码不会被歪果仁读到</li>
</ul>
</div>
</section><section id="块注释" class="slide level2">
<h1>块注释</h1>
<ul>
<li class="fragment">块注释一般针对其下方的代码, 与所解释的代码缩进保持一致.</li>
<li class="fragment">每行注释以 <code>#</code> 后面紧跟一个空格开始(其中内容有缩进的话可以有多个空格).</li>
<li class="fragment">注释内的段落分段的空行只包含一个 <code>#</code></li>
</ul>
</section><section id="行内注释" class="slide level2">
<h1>行内注释</h1>
<ul>
<li class="fragment">谨慎地使用行内注释</li>
<li class="fragment">行内注释和语句在同一行, 注释需要与语句之间用两个空格以上空格隔开</li>
<li class="fragment">注释的 <code>#</code> 后面也要有一个空格</li>
<li class="fragment">如果代码的意思很明显, 则需要避免行内注释</li>
</ul>
<div class="fragment">
<p>下面的注释不需要</p>
<pre class="python"><code>x = x + 1                 # Increment x</code></pre>
<p>有时候也有必要</p>
<pre class="python"><code>x = x + 1                 # Compensate for border</code></pre>
</div>
</section><section id="文档字符串" class="slide level2">
<h1>文档字符串</h1>
<p>文档字符串(docstrings)经常充当解释代码意图的作用.</p>
<p>如何写好文档字符串, 有专门的 <a href="https://www.python.org/dev/peps/pep-0257">PEP 257</a>介绍.</p>
</section><section class="slide level2">

<h3 id="如何写文档字符串">如何写文档字符串</h3>
<ul>
<li class="fragment">一般是针对public的模块/函数/类/方法等编写docstring.</li>
<li class="fragment">私有的方法一般没必要写docstring, 但是往往需要添加注释, 则注释一般加在 <code>def</code> 行的下面.</li>
<li class="fragment">结尾的 <code>&quot;&quot;&quot;</code> 的位置, 如果是多行内容, 结尾引号独占一行;</li>
<li class="fragment">如果只有一行内容, 结尾引号可以在同一行.</li>
</ul>
<div class="fragment">
<pre class="python"><code>&quot;&quot;&quot;Return a foobang

Optional plotz says to frobnicate the bizbaz first.
&quot;&quot;&quot;</code></pre>
</div>
</section></section>
<section><section id="命名规范" class="titleslide slide level1"><h1>命名规范</h1></section><section id="遵循现状" class="slide level2">
<h1>遵循现状</h1>
<ul>
<li class="fragment"><p>Python库中的命名规范比较混乱, 所以永远不可能达到彻底的统一.</p></li>
<li class="fragment"><p>下面要介绍的是当前推荐的命名规范和标准, 在实现新的模块或库时, 需要遵守这些规范.</p></li>
<li class="fragment"><p>但是对于已有的不同风格的库, 还是更建议遵循现状, 保持其内部的一致性.</p></li>
</ul>
</section><section id="最重要的原则" class="slide level2">
<h1>最重要的原则</h1>
<p>需要以public API暴露给用户的命名需要遵从:</p>
<p><strong>反映用途, 而不是实现.</strong></p>
</section><section id="命名风格" class="slide level2">
<h1>命名风格</h1>
<p>存在多种不同的命名风格.</p>
<ul>
<li class="fragment">b (单个小写字母)</li>
<li class="fragment">B (单个大写字母)</li>
<li class="fragment">lowercase</li>
<li class="fragment">lower_case_with_underscores</li>
<li class="fragment">UPPERCASE</li>
<li class="fragment">UPPER_CASE_WITH_UNDERSCORES</li>
<li class="fragment">CapitalizedWords (又称CamelCase, 即驼峰命名法)</li>
<li class="fragment">mixedCase</li>
<li class="fragment">Capitalized_Words_With_Underscores (丑陋!)</li>
</ul>
</section><section class="slide level2">

<h3 id="一些特殊的前缀">一些特殊的前缀</h3>
<ul>
<li class="fragment"><p>有一种命名风格是在名称前面带上一个特别的短前缀, 用来分类标示相关联的名称.</p></li>
<li class="fragment"><p>这种用法在Python中不多见, 主要是一些比较古老的实现, 例如:</p>
<p><code>os.stat()</code> 函数返回的元组中的项的传统命名是 <code>st_mode , st_size , st_mtime</code>, 这样做是为了和POSIX系统调用的结构体字段保持一致.</p></li>
<li class="fragment"><p>一般情况下, 应该避免使用这种带前缀的命名风格.</p></li>
</ul>
</section><section class="slide level2">

<h3 id="下划线前缀后缀">下划线前缀/后缀</h3>
<p>下划线作为前缀/后缀有以下几种情况(可以和不同的大小写风格组合):</p>
<ul>
<li class="fragment"><p><code>_single_leading_underscore</code></p>
<p>&quot;内部使用&quot; 标示</p></li>
<li class="fragment"><p><code>single_trailing_underscore_</code></p>
<p>用于避免和Python关键字冲突</p></li>
<li class="fragment"><p><code>__double_leading_underscore</code></p>
<p>作为类的属性时, invokes name mangling (inside class FooBar, __boo becomes _FooBar__boo ; see below).</p></li>
<li class="fragment"><p><code>__double_leading_and_trailing_underscore__</code></p>
<p>&quot;magic&quot; objects or attributes that live in user-controlled namespaces</p></li>
</ul>
</section><section id="命名规范-1" class="slide level2">
<h1>命名规范</h1>
</section><section class="slide level2">

<h3 id="避免用到的名字">避免用到的名字</h3>
<p>单字符变量应该避免使用: <code>l O I</code></p>
<ul>
<li class="fragment">选择一个合适的字体, 可以比较清楚的区分这些字符</li>
</ul>
</section><section class="slide level2">

<h3 id="包和模块名">包和模块名</h3>
<ul>
<li class="fragment"><p>模块名应该使用简短的, 全小写的名称</p></li>
<li class="fragment"><p>如果有助于增强可读性, 模块名可以使用下划线</p></li>
<li class="fragment"><p>包的名称也应该是简短的, 全小写, 但是不推荐使用下划线</p></li>
</ul>
</section><section class="slide level2">

<h3 id="类的命名">类的命名</h3>
<ul>
<li class="fragment"><p>类名一般使用驼峰命名法, CapWords</p></li>
<li class="fragment"><p>某些情况下, 类被当作callable使用, 这时适用于函数命名规范</p></li>
<li class="fragment"><p>builtin名称是特例, 大部分的builtin名是一个小写单词(或两个词连一起), 除了</p></li>
<li class="fragment"><p>异常和常量是使用驼峰命名</p></li>
</ul>
<pre class="python"><code>&gt;&gt;&gt; import __builtin__
&gt;&gt;&gt; dir(__builtin__)
[&#39;ArithmeticError&#39;, &#39;AssertionError&#39;, &#39;AttributeError&#39;, &#39;BaseException&#39;, &#39;BufferError&#39;, &#39;BytesWarning&#39;, &#39;DeprecationWarning&#39;, &#39;EOFError&#39;, &#39;Ellipsis&#39;, &#39;EnvironmentError&#39;, &#39;Exception&#39;, &#39;False&#39;, &#39;FloatingPointError&#39;, &#39;FutureWarning&#39;, &#39;GeneratorExit&#39;, &#39;IOError&#39;, &#39;ImportError&#39;, &#39;ImportWarning&#39;, &#39;IndentationError&#39;, &#39;IndexError&#39;, &#39;KeyError&#39;, &#39;KeyboardInterrupt&#39;, &#39;LookupError&#39;, &#39;MemoryError&#39;, &#39;NameError&#39;, &#39;None&#39;, &#39;NotImplemented&#39;, &#39;NotImplementedError&#39;, &#39;OSError&#39;, &#39;OverflowError&#39;, &#39;PendingDeprecationWarning&#39;, &#39;ReferenceError&#39;, &#39;RuntimeError&#39;, &#39;RuntimeWarning&#39;, &#39;StandardError&#39;, &#39;StopIteration&#39;, &#39;SyntaxError&#39;, &#39;SyntaxWarning&#39;, &#39;SystemError&#39;, &#39;SystemExit&#39;, &#39;TabError&#39;, &#39;True&#39;, &#39;TypeError&#39;, &#39;UnboundLocalError&#39;, &#39;UnicodeDecodeError&#39;, &#39;UnicodeEncodeError&#39;, &#39;UnicodeError&#39;, &#39;UnicodeTranslateError&#39;, &#39;UnicodeWarning&#39;, &#39;UserWarning&#39;, &#39;ValueError&#39;, &#39;Warning&#39;, &#39;ZeroDivisionError&#39;, &#39;__debug__&#39;, &#39;__doc__&#39;, &#39;__import__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;abs&#39;, &#39;all&#39;, &#39;any&#39;, &#39;apply&#39;, &#39;basestring&#39;, &#39;bin&#39;, &#39;bool&#39;, &#39;buffer&#39;, &#39;bytearray&#39;, &#39;bytes&#39;, &#39;callable&#39;, &#39;chr&#39;, &#39;classmethod&#39;, &#39;cmp&#39;, &#39;coerce&#39;, &#39;compile&#39;, &#39;complex&#39;, &#39;copyright&#39;, &#39;credits&#39;, &#39;delattr&#39;, &#39;dict&#39;, &#39;dir&#39;, &#39;divmod&#39;, &#39;enumerate&#39;, &#39;eval&#39;, &#39;execfile&#39;, &#39;exit&#39;, &#39;file&#39;, &#39;filter&#39;, &#39;float&#39;, &#39;format&#39;, &#39;frozenset&#39;, &#39;getattr&#39;, &#39;globals&#39;, &#39;hasattr&#39;, &#39;hash&#39;, &#39;help&#39;, &#39;hex&#39;, &#39;id&#39;, &#39;input&#39;, &#39;int&#39;, &#39;intern&#39;, &#39;isinstance&#39;, &#39;issubclass&#39;, &#39;iter&#39;, &#39;len&#39;, &#39;license&#39;, &#39;list&#39;, &#39;locals&#39;, &#39;long&#39;, &#39;map&#39;, &#39;max&#39;, &#39;memoryview&#39;, &#39;min&#39;, &#39;next&#39;, &#39;object&#39;, &#39;oct&#39;, &#39;open&#39;, &#39;ord&#39;, &#39;pow&#39;, &#39;print&#39;, &#39;property&#39;, &#39;quit&#39;, &#39;range&#39;, &#39;raw_input&#39;, &#39;reduce&#39;, &#39;reload&#39;, &#39;repr&#39;, &#39;reversed&#39;, &#39;round&#39;, &#39;set&#39;, &#39;setattr&#39;, &#39;slice&#39;, &#39;sorted&#39;, &#39;staticmethod&#39;, &#39;str&#39;, &#39;sum&#39;, &#39;super&#39;, &#39;tuple&#39;, &#39;type&#39;, &#39;unichr&#39;, &#39;unicode&#39;, &#39;vars&#39;, &#39;xrange&#39;, &#39;zip&#39;]</code></pre>
</section><section class="slide level2">

<h3 id="异常的命名">异常的命名</h3>
<ul>
<li class="fragment"><p>因为异常是类, 所以应该遵从类的命名规范, 使用驼峰法</p></li>
<li class="fragment"><p>一般异常类名后缀以 <code>Error</code> 结尾</p></li>
</ul>
</section><section class="slide level2">

<h3 id="全局变量的命名">全局变量的命名</h3>
<ul>
<li class="fragment"><p>全局变量指的就是模块级别的变量</p></li>
<li class="fragment"><p>全局变量的命名规范和函数一样</p></li>
<li class="fragment"><p>如果模块被设计来通过 <code>import *</code> 暴露其中的名称, 则应该使用 <code>__all__</code> 机制, 或者使用下划线开头的名称</p></li>
</ul>
</section><section class="slide level2">

<h3 id="函数的命名">函数的命名</h3>
<ul>
<li class="fragment"><p>函数名应该是小写</p></li>
<li class="fragment"><p>单词之间使用下划线分隔以提高可读性</p></li>
<li class="fragment"><p>为了向后兼容, 也可以使用 mixedCase 风格, 保持上下文的一致性</p></li>
</ul>
</section><section class="slide level2">

<h3 id="函数和方法的参数命名">函数和方法的参数命名</h3>
<ul>
<li class="fragment"><p>参数名应该是小写</p></li>
<li class="fragment"><p>单词之间使用下划线分隔以提高可读性</p></li>
<li class="fragment"><p>实例方法的第一个参数名总是 <code>self</code></p></li>
<li class="fragment"><p>类方法的第一个参数名总是 <code>cls</code></p></li>
<li class="fragment"><p>如果参数名和Python关键字冲突, 一般的做法是加一个下划线做后缀(或者找个同义词)</p></li>
</ul>
</section><section class="slide level2">

<h3 id="方法的命名和实例变量">方法的命名和实例变量</h3>
<ul>
<li class="fragment"><p>和函数的命名规范一致</p></li>
<li class="fragment"><p>使用下划线前缀来标示 non-public</p></li>
<li class="fragment"><p>如果要避免和子类发生命名冲突, 使用双下划线前缀</p></li>
</ul>
</section><section class="slide level2">

<h3 id="常量的命名">常量的命名</h3>
<ul>
<li class="fragment"><p>常量的作用范围一般定义为模块级别</p></li>
<li class="fragment"><p>使用全大写字母, 中间用下划线隔开, 如 <code>MAX_LENGTH</code></p></li>
</ul>
</section><section id="关于继承的设计" class="slide level2">
<h1>关于继承的设计</h1>
<ul>
<li class="fragment"><p>想清楚类/实例的方法或变量是public还是non-public</p></li>
<li class="fragment"><p>如果有疑惑, 选择non-public, 这样以后转为public也更容易</p></li>
<li class="fragment"><p>non-public 不等同于其他语言的 <code>private</code>, 实际上Python中没有真正意义上的private</p></li>
</ul>
</section><section class="slide level2">

<h3 id="一些pythonic的建议">一些Pythonic的建议</h3>
<ul>
<li class="fragment"><p>Public 属性没有下划线前缀</p></li>
<li class="fragment"><p>如果 public 属性名和关键字冲突, 使用下划线后缀</p></li>
<li class="fragment"><p>使用property, 尽量保证函数式行为</p></li>
<li class="fragment"><p>如果类被设计为基类, 但是不想其中的属性被继承, 使用双下划线前缀</p></li>
</ul>
</section><section id="外部和内部接口" class="slide level2">
<h1>外部和内部接口</h1>
</section></section>
<section><section id="编码建议" class="titleslide slide level1"><h1>编码建议</h1></section><section id="编写与python实现无关的代码" class="slide level2">
<h1>编写与Python实现无关的代码</h1>
<ul>
<li class="fragment"><p>Python有多种实现(PyPy, Jython, IronPython, Cython, Psyco等等)</p></li>
<li class="fragment"><p>不要编写在某种特定实现下比较高效的代码</p>
<p>例如: CPython实现中的字符串就地拼接(<code>a += b</code> 或 <code>a = a + b</code>)比较高效, 然而这种优化是不可靠的, 出于性能的考虑, 应该使用标准库的 <code>''.join()</code> 方法.</p></li>
</ul>
</section><section id="单体的比较" class="slide level2">
<h1>单体的比较</h1>
<ul>
<li class="fragment"><p>单体(singletons), 如 <code>None</code> 的比较使用 <code>is</code> 和 <code>is not</code>, 而不是 <code>==</code></p></li>
<li class="fragment"><p>在 <code>if</code> 语句中注意 <code>if x</code> 和 <code>if x is not None</code> 的区别.</p></li>
</ul>
<div class="fragment">
<pre class="python"><code>x = None

def count(x):
    if x:
        return len(x)
    else:
        return 0

def init(x):
    if x is None:
        x = []</code></pre>
</div>
</section><section class="slide level2">

<p>使用 <code>is not</code>, 而不是 <code>not ... is</code></p>
<pre class="python"><code># Yes:
if foo is not None:

# No:
if not foo is None:</code></pre>
</section><section id="rich-comparisons" class="slide level2">
<h1>Rich Comparisons</h1>
<ul>
<li class="fragment"><p>要实现丰富比较, 最好一次性实现6种操作 (<code>__eq__ , __ne__ , __lt__ , __le__ , __gt__ , __ge__</code>)</p></li>
<li class="fragment"><p><code>functools.total_ordering()</code> 可以帮助简化实现</p></li>
<li class="fragment"><p>Python假定操作是自反的, 例如, 解释器有可能会将 <code>x &lt; y</code> 调换为 <code>x &gt; y</code></p></li>
</ul>
</section><section id="lambda赋值" class="slide level2">
<h1>lambda赋值</h1>
<ul>
<li class="fragment"><p>避免使用 <code>lamda</code> 语句赋值给函数对象</p></li>
<li class="fragment"><p><code>lamda</code> 语句相对于 <code>def</code> 语句的优势是可以嵌入在一个长表达式中, 使用了赋值实际上就消除了这一点</p></li>
</ul>
<div class="fragment">
<pre class="python"><code># Yes:
def f(x): return 2*x

# No:
f = lambda x: 2*x</code></pre>
</div>
</section><section id="派生异常类" class="slide level2">
<h1>派生异常类</h1>
<ul>
<li class="fragment"><p>定义异常派生类时, 选择 <code>Exception</code> 作为基类, 而不是 <code>BaseException</code></p></li>
<li class="fragment"><p>Aim to answer the question &quot;What went wrong?&quot; programmatically, rather than only stating that &quot;A problem occurred&quot;</p></li>
<li class="fragment"><p>遵从类的命名规范, 一般会带上Error后缀, 当然有些异常不算是错误的话, 也可以省略</p></li>
</ul>
</section><section id="异常链" class="slide level2">
<h1>异常链</h1>
<ul>
<li class="fragment"><p>Python3中需要使用 <code>raise X from Y</code> 来显式的表明异常替换, 保留完整的traceback</p></li>
<li class="fragment"><p>如果确实要替换异常, 使用 <code>raise X</code> in Python2, <code>raise X from None</code> in Python 3.3+</p></li>
<li class="fragment"><p>如果要替换抛出的异常, 一般要确保把前一个异常的详细信息保留下来</p></li>
</ul>
</section><section id="抛异常" class="slide level2">
<h1>抛异常</h1>
<ul>
<li class="fragment"><p>Python2中, 使用 <code>raise ValueError('message')</code>, 而不是 <code>raise ValueError, 'message'</code></p></li>
<li class="fragment"><p>后者的语法在Python3中已经淘汰</p></li>
</ul>
</section><section id="捕获异常" class="slide level2">
<h1>捕获异常</h1>
<ul>
<li class="fragment"><p>当捕获异常时, 尽量指明特定的异常类型, 而不是空的 <code>except:</code> 语句</p></li>
<li class="fragment"><p>空 <code>except:</code> 会同时捕获 <code>SystemExit</code> 和 <code>KeyboardInterrupt</code>, 使得程序难以用 Ctrl-C停止, 同时掩盖其它异常</p></li>
<li class="fragment"><p>如果想捕获所有异常, 使用 <code>except Exception:</code></p></li>
<li class="fragment"><p><code>except:</code> 等同于 <code>except BaseException:</code></p></li>
</ul>
<pre class="python"><code>try:
    import platform_specific_module
except ImportError:
    platform_specific_module = None</code></pre>
</section><section class="slide level2">

<ul>
<li class="fragment">需要绑定捕获到的异常时, 使用如下的语法:</li>
</ul>
<pre class="python"><code>try:
    process_data()
except Exception as exc:
    raise DataProcessingFailedError(str(exc))</code></pre>
<ul>
<li class="fragment">下面Python2中老式的逗号分隔的语法在Python3中已经废弃</li>
</ul>
<pre class="python"><code>try:
    process_data()
except Exception, exc:
    raise DataProcessingFailedError(str(exc))</code></pre>
</section><section class="slide level2">

<p>When catching operating system errors, prefer the explicit exception hierarchy introduced in Python 3.3 over introspection of <code>errno</code> values.</p>
</section><section class="slide level2">

<p>Additionally, for all try/except clauses, limit the try clause to the absolute minimum amount of code necessary. Again, this avoids masking bugs.</p>
<pre class="python"><code># Yes:
try:
    value = collection[key]
except KeyError:
    return key_not_found(key)
else:
    return handle_value(value)

# No:
try:
    # Too broad!
    return handle_value(collection[key])
except KeyError:
    # Will also catch KeyError raised by handle_value()
    return key_not_found(key)</code></pre>
</section><section class="slide level2">

</section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
    </body>
</html>
