<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="司大伟">
  <meta name="dcterms.date" content="2016-06-25">
  <title>Python编码规范</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">code{white-space: pre;}</style>

<!-- For syntax highlighting -->
  <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

  <link rel="stylesheet" href="reveal.js/css/theme/beige.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
  <h1 class="title">Python编码规范</h1>
  <h2 class="author">司大伟</h2>
  <h3 class="date">2016-06-25</h3>
</section>

<section><section id="前言" class="titleslide slide level1"><h1>前言</h1></section><section id="python之禅" class="slide level2">
<h1>Python之禅</h1>
<pre><code>&gt;&gt;&gt; import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren&#39;t special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you&#39;re Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it&#39;s a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let&#39;s do more of those!</code></pre>
<div class="fragment">
<p><a href="https://www.python.org/dev/peps/pep-0020/">PEP20</a> = The Zen of Python</p>
</div>
</section><section id="大括号" class="slide level2">
<h1>大括号？</h1>
<h3 id="没门">没门！</h3>
<pre class="python"><code>&gt;&gt;&gt; from __future__ import braces
SyntaxError: not a chance (&lt;input&gt;, line 1)</code></pre>
</section></section>
<section><section id="概述" class="titleslide slide level1"><h1>概述</h1></section><section id="为何要代码规范" class="slide level2">
<h1>为何要代码规范</h1>
<blockquote>
<p><strong>Programs must be written for people to read, and only incidentally for machines to execute.</strong> <strong>程序是写来给人读的,只是顺带让机器执行。</strong> --- Abelson &amp; Sussman, <a href="https://book.douban.com/subject/1148282/">计算机程序的构造和解释</a></p>
</blockquote>
</section><section id="什么是pep8" class="slide level2">
<h1>什么是PEP8</h1>
<p>PEP = Python Enhancement Proposal</p>
<p><a href="https://www.python.org/dev/peps/pep-0008/">PEP8</a> = Style Guide for Python Code</p>
</section><section class="slide level2">

<h3 id="规范的意义">规范的意义</h3>
<ul>
<li class="fragment"><p>规范的意义在于保持一致性(consistency).</p></li>
<li class="fragment"><p>保持一致的风格是重要的.</p></li>
<li class="fragment"><p>在一个项目中保持一致的风格则更重要.</p></li>
<li class="fragment"><p>在一个模块或函数中保持一致性是最重要的.</p></li>
</ul>
</section><section class="slide level2">

<h3 id="莫要愚蠢的坚持">莫要愚蠢的坚持</h3>
<p>一致性虽然重要, 但最最重要的是: <strong>知道何时会不一致</strong></p>
<p>有时候会觉得风格指导难以应用, 当有疑惑时, 多思考, 多参考其它例子, 做出自己最好的判断!</p>
<ul>
<li class="fragment">使得代码可读性变差</li>
<li class="fragment">破坏当前代码风格的连续性(比如历史原因)</li>
<li class="fragment">当代码需要保持向后兼容性</li>
</ul>
</section></section>
<section><section id="代码布局" class="titleslide slide level1"><h1>代码布局</h1></section><section id="缩进" class="slide level2">
<h1>缩进</h1>
<h3 id="空格-or-tab">空格 or Tab?</h3>
<ul>
<li class="fragment">使用4个空格作为一级缩进</li>
<li class="fragment">_永远_不要混用Tab和空格(事实上混用了会无法执行)</li>
<li class="fragment">设置编辑器自动将Tab转为空格</li>
</ul>
</section><section class="slide level2">

<h3 id="断行的对齐">断行的对齐</h3>
<p>被括号括起来的连续的长行, 比如函数定义/调用, 列表, 字典, 在换行时有两种对齐风格.</p>
<p>一种是垂直对齐.</p>
<pre class="python"><code># 以括号为界, 垂直对齐.
foo = long_function_name(var_one, var_two,
                         var_three, var_four)
</code></pre>
<div class="fragment">
<p>一种是悬挂式缩进(hanging indent)</p>
<pre class="python"><code># 从括号起始就换行, 比正常的缩进多缩进一点以示区分.
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)</code></pre>
</div>
</section><section class="slide level2">

<h3 id="不好的风格">不好的风格</h3>
<pre class="python"><code># 没有垂直对齐, 第一行参数就显得不突出.
foo = long_function_name(var_one, var_two,
    var_three, var_four)

# 和正常的函数体语句缩进一样, 不好区分.
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)</code></pre>
</section><section class="slide level2">

<h3 id="if语句的缩进">IF语句的缩进</h3>
<p>当if语句后面的条件判断需要折行时, if占2个字符, 加上空格和左括号, 总共刚好是4个字符. 也就是说, 这时候如果是垂直对齐的话, 就和下面的语句缩进一样了, 例如:</p>
<pre class="python"><code># No extra indentation.
if (this_is_one_thing and
    that_is_another_thing):
    do_something()</code></pre>
</section><section class="slide level2">

<h3 id="if语句的缩进-1">IF语句的缩进</h3>
<pre class="python"><code># 添加一行注释, 这样在语法高亮的编辑器中会显得有所区别
# 但是pycharm中的pep8检测还是会提示
if (this_is_one_thing and
    that_is_another_thing):
    # Since both conditions are true, we can frobnicate.
    do_something()

# 增加额外的缩进.
if (this_is_one_thing
        and that_is_another_thing):
    do_something()</code></pre>
</section><section class="slide level2">

<h3 id="右括号的位置">右括号的位置</h3>
<p>多行语句中右括号(包括 圆括号,方括号,花括号)的位置也有两种情况</p>
<pre class="python"><code># 和第一个非空字符对齐
my_list = [
    1, 2, 3,
    4, 5, 6,
    ]
result = some_function_that_takes_arguments(
    &#39;a&#39;, &#39;b&#39;, &#39;c&#39;,
    &#39;d&#39;, &#39;e&#39;, &#39;f&#39;,
    )</code></pre>
<div class="fragment">
<pre class="python"><code># 置于行首
my_list = [
    1, 2, 3,
    4, 5, 6,
]
result = some_function_that_takes_arguments(
    &#39;a&#39;, &#39;b&#39;, &#39;c&#39;,
    &#39;d&#39;, &#39;e&#39;, &#39;f&#39;,
)</code></pre>
</div>
</section><section class="slide level2">

<h3 id="二元运算符的位置">二元运算符的位置</h3>
<pre class="python"><code># No: 运算符和运算对象离得太远了
income = (gross_wages +
          taxable_interest +
          (dividends - qualified_dividends) -
          ira_deduction -
          student_loan_interest)</code></pre>
<pre class="python"><code># Yes: 运算符和运算对象很容易匹配
income = (gross_wages
          + taxable_interest
          + (dividends - qualified_dividends)
          - ira_deduction
          - student_loan_interest)</code></pre>
</section><section id="空行" class="slide level2">
<h1>空行</h1>
<ul>
<li class="fragment">顶层的函数和类定义之间用两个空行隔开</li>
<li class="fragment">类中的方法定义之间用一个空行隔开</li>
<li class="fragment">使用额外的空行来区分某组相关联的函数(保守使用)</li>
<li class="fragment">在函数中也可以用空行分隔不同的逻辑段(保守使用)</li>
<li class="fragment">连续的单行语句之间的空行可以省略</li>
</ul>
</section><section id="源文件编码" class="slide level2">
<h1>源文件编码</h1>
<ul>
<li class="fragment">Python2中默认的编码是ASCII</li>
<li class="fragment">Python3中默认的编码是UTF-8</li>
<li class="fragment">使用默认编码的无需编码声明</li>
</ul>
</section><section id="模块导入" class="slide level2">
<h1>模块导入</h1>
<p>import语句一般都要独占一行</p>
<pre class="python"><code>Yes: import os
     import sys

No:  import sys, os</code></pre>
<p>但是下面这种也可以接受</p>
<pre class="python"><code>from subprocess import Popen, PIPE</code></pre>
</section><section class="slide level2">

<h3 id="import语句的顺序">import语句的顺序</h3>
<p>import 语句一般总是在文件的上方, 接在模块注释和Docstring的后面, 在模块全局变量和常量之前.</p>
<p>import 语句应该遵从下面的顺序:</p>
<ol type="1">
<li class="fragment">标准库</li>
<li class="fragment">第三方库</li>
<li class="fragment">当前应用/库</li>
</ol>
</section><section class="slide level2">

<h3 id="绝对路径import">绝对路径import</h3>
<p>推荐使用绝对路径的import语句, 因为可读性更好.</p>
<p>当import出现问题时, 绝对路径可以提供更多的错误信息</p>
<pre class="python"><code>import mypkg.sibling
from mypkg import sibling
from mypkg.sibling import example</code></pre>
</section><section class="slide level2">

<h3 id="显式相对路径import">显式相对路径import</h3>
<p>当情况比较复杂时, <em>显式</em> 相对路径import也是可以的.</p>
<pre class="python"><code>from . import sibling
from .sibling import example</code></pre>
<p>避免使用隐式相对路径import, 这种方式在Python3中已经被淘汰.</p>
<!-- 隐式import的例子 -->
</section><section class="slide level2">

<h3 id="从模块中import类">从模块中import类</h3>
<p>可以直接import类</p>
<pre class="python"><code>from myclass import MyClass
from foo.bar.yourclass import YourClass</code></pre>
<p>如果要引入的类名和本地名称冲突, 也可以这样:</p>
<pre class="python"><code>import myclass
import foo.bar.yourclass

obj = myclass.MyClass()</code></pre>
</section><section class="slide level2">

<h3 id="避免使用import">避免使用import *</h3>
<p>尽量避免使用import *语句, 这样会造成本地命名空间不清晰, 对阅读代码以及一些自动化处理工具都会造成困扰.</p>
<p>只有一种例外的情况:</p>
<p><em>当需要把内部接口重新发布为外部接口</em></p>
</section><section id="module中的-__name__" class="slide level2">
<h1>module中的 <em><code>__name__</code></em></h1>
<p>模块级别的特殊名称, 即以两个下划线开始和结束的名称如 <code>__all__</code> , <code>__author__</code> , <code>__version__</code> 等. 位置应该:</p>
<ul>
<li class="fragment">置于docstring之后,</li>
<li class="fragment">import语句之前,</li>
<li class="fragment">除了 from <code>__future__</code> import xx</li>
</ul>
</section><section class="slide level2">

<h3 id="举例">举例</h3>
<pre class="python"><code>&quot;&quot;&quot;This is the example module.

This module does stuff.
&quot;&quot;&quot;

from __future__ import barry_as_FLUFL

__all__ = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
__version__ = &#39;0.1&#39;
__author__ = &#39;Cardinal Biggles&#39;

import os
import sys</code></pre>
</section></section>
<section><section id="空白" class="titleslide slide level1"><h1>空白</h1></section><section id="不要加空格的地方" class="slide level2">
<h1>不要加空格的地方</h1>
<p>以下几种情况应该避免使用无关的空格</p>
</section><section class="slide level2">

<p>括号内部两边紧挨着括号的地方不要有空格</p>
<pre class="python"><code>Yes: spam(ham[1], {eggs: 2})
No:  spam( ham[ 1 ], { eggs: 2 } )</code></pre>
</section><section class="slide level2">

<p>冒号, 逗号, 分号的前面不要有空格</p>
<pre class="python"><code>Yes: if x == 4: print x, y; x, y = y, x
No:  if x == 4 : print x , y ; x , y = y , x</code></pre>
</section><section class="slide level2">

<p>切片语句中的冒号</p>
<p>切片语句中, 冒号的作用类似于二元运算符, 在某些情况下可以在两边有对等的空格</p>
<pre class="python"><code>ham[1:9], ham[1:9:3], ham[:9:3], ham[1::3], ham[1:9:]
ham[lower:upper], ham[lower:upper:], ham[lower::step]
ham[lower+offset : upper+offset]
ham[: upper_fn(x) : step_fn(x)], ham[:: step_fn(x)]
ham[lower + offset : upper + offset]</code></pre>
</section><section class="slide level2">

<p>紧跟在函数调用后面的括号</p>
<pre class="python"><code>Yes: spam(1)
No:  spam (1)</code></pre>
</section><section class="slide level2">

<p>紧跟在索引或切片后面的括号</p>
<pre class="python"><code>Yes: dct[&#39;key&#39;] = lst[index]
No:  dct [&#39;key&#39;] = lst [index]</code></pre>
</section><section class="slide level2">

<p>不要为了对齐在运算符两边添加多余的空格</p>
<pre class="python"><code># Yes:
x = 1
y = 2
long_variable = 3

# No:
x             = 1
y             = 2
long_variable = 3</code></pre>
</section><section id="其它建议" class="slide level2">
<h1>其它建议</h1>
</section><section class="slide level2">

<h3 id="避免行末拖尾的空格">避免行末拖尾的空格</h3>
<ul>
<li class="fragment">避免在任何地方出现拖尾的空格, 因为编辑器中这些空格一般都不可见, 可能会导致困扰.</li>
<li class="fragment">例如如果一个反斜杠后面跟有空格, 则这个反斜杠就起不到续行的作用.</li>
<li class="fragment">有的编辑器(包括PyCharm)会在保存文件时自动去除这些空格.</li>
</ul>
</section><section class="slide level2">

<h3 id="二元操作符">二元操作符</h3>
<p>总是在二元操作符两边都加一个空格. 包括:</p>
<ul>
<li class="fragment">赋值符: <code>=</code></li>
<li class="fragment">增量赋值: <code>+= , -=</code> 等</li>
<li class="fragment">比较符: <code>== , &lt; , &gt; , != , &lt;&gt; , &lt;= , &gt;= , in , not in , is , is not</code></li>
<li class="fragment">布尔操作: <code>and , or , not</code></li>
</ul>
</section><section class="slide level2">

<p>如果涉及到多个优先级的操作符, 可以考虑在较低优先级的操作符两边加空格, 省略高优先级操作符两边的空格.</p>
<p>YES:</p>
<pre class="python"><code>i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)</code></pre>
<p>NO:</p>
<pre class="python"><code>i=i+1
submitted +=1
# 以下情况实际也是可以接受的, 例如
# pycharm自动格式化的结果就是在运算符两边统一加空格
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)</code></pre>
</section><section class="slide level2">

<p>在定义默认参数值的时候不要在 <code>=</code> 两边加空格.</p>
<p>YES:</p>
<pre class="python"><code>def complex(real, imag=0.0):
    return magic(r=real, i=imag)</code></pre>
<p>NO:</p>
<pre class="python"><code>def complex(real, imag = 0.0):
    return magic(r = real, i = imag)</code></pre>
</section><section class="slide level2">

<p>不建议把多条语句放在同一行</p>
<p>YES:</p>
<pre class="python"><code>if foo == &#39;blah&#39;:
    do_blah_thing()
do_one()
do_two()
do_three()</code></pre>
<p>NO:</p>
<pre class="python"><code>if foo == &#39;blah&#39;: do_blah_thing()
do_one(); do_two(); do_three()</code></pre>
</section><section class="slide level2">

<p>偶尔有些情况下, if/for/while/ 语句非常短, 放在一行是可以接受的(虽然不建议), 例如</p>
<pre class="python"><code># pycharm这种情况会提示, 但是自动格式化不会修改
if foo == &#39;blah&#39;: do_blah_thing()</code></pre>
<p>但是在有多个子句时绝对不要这样做!</p>
<pre class="python"><code>if foo == &#39;blah&#39;: do_blah_thing()
else: do_non_blah_thing()

try: something()
finally: cleanup()

do_one(); do_two(); do_three(long, argument,
                             list, like, this)

if foo == &#39;blah&#39;: one(); two(); three()</code></pre>
</section></section>
<section><section id="注释" class="titleslide slide level1"><h1>注释</h1></section><section id="注意事项" class="slide level2">
<h1>注意事项</h1>
<ul>
<li class="fragment">与代码矛盾的注释不如没有, 请记得及时同步更新注释</li>
</ul>
<div class="fragment">
<p>以下建议主要针对英语:</p>
<ul>
<li class="fragment">最好把注释写成完整的句子, 所以请注意句首大小写(除了该词是一个标识符)</li>
<li class="fragment">如果注释很短, 可以忽略句号, 但是如果包含多个句子, 则每句都应该以句号结尾</li>
<li class="fragment">请遵从英文写作指南</li>
</ul>
</div>
<div class="fragment">
<p>但是, 最后一个建议是...</p>
<ul>
<li class="fragment">非英语国的coder请使用English写注释, 除非120%确定该代码不会被歪果仁读到</li>
</ul>
</div>
</section><section id="块注释" class="slide level2">
<h1>块注释</h1>
<ul>
<li class="fragment">块注释一般针对其下方的代码, 与所解释的代码缩进保持一致.</li>
<li class="fragment">每行注释以 <code>#</code> 后面紧跟一个空格开始(其中内容有缩进的话可以有多个空格).</li>
<li class="fragment">注释内的段落分段的空行只包含一个 <code>#</code></li>
</ul>
</section><section id="行内注释" class="slide level2">
<h1>行内注释</h1>
<ul>
<li class="fragment">谨慎地使用行内注释</li>
<li class="fragment">行内注释和语句在同一行, 注释需要与语句之间用两个空格以上空格隔开</li>
<li class="fragment">注释的 <code>#</code> 后面也要有一个空格</li>
<li class="fragment">如果代码的意思很明显, 则需要避免行内注释</li>
</ul>
<div class="fragment">
<p>下面的注释不需要</p>
<pre class="python"><code>x = x + 1                 # Increment x</code></pre>
<p>有时候也有必要</p>
<pre class="python"><code>x = x + 1                 # Compensate for border</code></pre>
</div>
</section><section id="todo注释" class="slide level2">
<h1>TODO注释</h1>
<ul>
<li class="fragment">在注释的开头增加 <code>TODO</code> 字样, 用来解释此处代码将来要做什么</li>
<li class="fragment">TODO后面可以在括号中加上自己名字, 用来提示其它人</li>
<li class="fragment">PyCharm编辑器默认会将 <code>TODO</code> 注释中TODO字样高亮显示, 并自动查找项目中所有的TODO List</li>
<li class="fragment">PyCharm 还支持其它的字样, 如 <code>FixMe</code>, 还能自定义设置(<code>Settings | Editor | TODO</code>)</li>
</ul>
<pre class="python"><code># TODO(Sdw) Change this to use relations.</code></pre>
</section><section id="文档字符串" class="slide level2">
<h1>文档字符串</h1>
<p>文档字符串(docstrings)经常充当解释代码意图的作用.</p>
<p>如何写好文档字符串, 有专门的 <a href="https://www.python.org/dev/peps/pep-0257">PEP 257</a>介绍.</p>
</section><section class="slide level2">

<h3 id="docstrings-comments">Docstrings &amp; Comments</h3>
<ul>
<li class="fragment">Docstrings = How to use code</li>
<li class="fragment"><p>Comments = Why (rationale) &amp; how code works</p></li>
<li class="fragment">文档字符串解释 <em>如何</em> 使用代码, 面向的读者是代码的 <em>用户</em>.</li>
<li class="fragment">注释主要用来解释代码 <em>为何</em> 这样写, 面向的读者是代码的 <em>维护者</em></li>
<li class="fragment"><p>这两类人中都包括了代码的作者, 也就是 <em>你</em>.</p></li>
</ul>
</section><section class="slide level2">

<h3 id="如何写文档字符串">如何写文档字符串</h3>
<ul>
<li class="fragment">一般是针对public的模块/函数/类/方法等编写docstring.</li>
<li class="fragment">私有的方法一般没必要写docstring, 但是往往需要添加注释, 则注释一般加在 <code>def</code> 行的下面.</li>
<li class="fragment">结尾的 <code>&quot;&quot;&quot;</code> 的位置, 如果是多行内容, 结尾引号独占一行;</li>
<li class="fragment">如果只有一行内容, 结尾引号可以在同一行.</li>
</ul>
<div class="fragment">
<pre class="python"><code>&quot;&quot;&quot;Return a foobang

Optional plotz says to frobnicate the bizbaz first.
&quot;&quot;&quot;</code></pre>
</div>
</section></section>
<section><section id="命名规范" class="titleslide slide level1"><h1>命名规范</h1></section><section id="遵循现状" class="slide level2">
<h1>遵循现状</h1>
<ul>
<li class="fragment"><p>Python库中的命名规范比较混乱, 所以永远不可能达到彻底的统一.</p></li>
<li class="fragment"><p>下面要介绍的是当前推荐的命名规范和标准, 在实现新的模块或库时, 需要遵守这些规范.</p></li>
<li class="fragment"><p>但是对于已有的不同风格的库, 还是更建议遵循现状, 保持其内部的一致性.</p></li>
</ul>
</section><section id="最重要的原则" class="slide level2">
<h1>最重要的原则</h1>
<p>需要以public API暴露给用户的命名需要遵从:</p>
<p><strong>反映用途, 而不是实现.</strong></p>
</section><section id="命名约定" class="slide level2">
<h1>命名约定</h1>
<ul>
<li class="fragment">所谓&quot;内部(Internal)&quot;表示仅模块内可用, 或者, 在类内是保护或私有的.</li>
<li class="fragment">用单下划线(<code>_</code>)开头表示模块变量或函数是protected的(使用<code>import *</code>时不会包含).</li>
<li class="fragment">用双下划线(<code>__</code>)开头的实例变量或方法表示类内私有.</li>
<li class="fragment">将相关的类和顶级函数放在同一个模块里. 不像Java, 没必要限制一个类一个模块.</li>
</ul>
</section><section id="命名风格" class="slide level2">
<h1>命名风格</h1>
<p>存在多种不同的命名风格.</p>
<ul>
<li class="fragment">b (单个小写字母)</li>
<li class="fragment">B (单个大写字母)</li>
<li class="fragment">lowercase</li>
<li class="fragment">lower_case_with_underscores</li>
<li class="fragment">UPPERCASE</li>
<li class="fragment">UPPER_CASE_WITH_UNDERSCORES</li>
<li class="fragment">CapitalizedWords (又称CamelCase, 即驼峰命名法)</li>
<li class="fragment">mixedCase</li>
<li class="fragment">Capitalized_Words_With_Underscores (丑陋!)</li>
</ul>
</section><section class="slide level2">

<h3 id="一些特殊的前缀">一些特殊的前缀</h3>
<ul>
<li class="fragment"><p>有一种命名风格是在名称前面带上一个特别的短前缀, 用来分类标示相关联的名称.</p></li>
<li class="fragment"><p>这种用法在Python中不多见, 主要是一些比较古老的实现, 例如:</p>
<p><code>os.stat()</code> 函数返回的元组中的项的传统命名是 <code>st_mode , st_size , st_mtime</code>, 这样做是为了和POSIX系统调用的结构体字段保持一致.</p></li>
<li class="fragment"><p>一般情况下, 应该避免使用这种带前缀的命名风格.</p></li>
</ul>
</section><section class="slide level2">

<h3 id="下划线前缀后缀">下划线前缀/后缀</h3>
<p>下划线作为前缀/后缀有以下几种情况(可以和不同的大小写风格组合):</p>
<ul>
<li class="fragment"><p><code>_single_leading_underscore</code></p>
<p>&quot;内部使用&quot; 标示</p></li>
<li class="fragment"><p><code>single_trailing_underscore_</code></p>
<p>用于避免和Python关键字冲突</p></li>
<li class="fragment"><p><code>__double_leading_underscore</code></p>
<p>作为类的属性时, invokes name mangling (inside class FooBar, __boo becomes _FooBar__boo ; see below).</p></li>
<li class="fragment"><p><code>__double_leading_and_trailing_underscore__</code></p>
<p>&quot;magic&quot; objects or attributes that live in user-controlled namespaces</p></li>
</ul>
</section><section id="命名规范-1" class="slide level2">
<h1>命名规范</h1>
</section><section class="slide level2">

<h3 id="应该避免的名称">应该避免的名称</h3>
<ul>
<li class="fragment"><p>避免使用单字符名称, 除了计数器和迭代器</p></li>
<li class="fragment"><p>单字符变量应该避免使用: <code>l O I</code> (选择一个合适的字体, 可以比较清楚的区分这些字符)</p></li>
<li class="fragment"><p>包/模块名称中使用连字符 (<code>-</code>)</p></li>
<li class="fragment"><p>双下划线开头并结尾的名称(Python保留)</p></li>
</ul>
</section><section class="slide level2">

<h3 id="包和模块名">包和模块名</h3>
<ul>
<li class="fragment"><p>模块名应该使用简短的, 全小写的名称</p></li>
<li class="fragment"><p>如果有助于增强可读性, 模块名可以使用下划线</p></li>
<li class="fragment"><p>包的名称也应该是简短的, 全小写, 但是不推荐使用下划线</p></li>
</ul>
</section><section class="slide level2">

<h3 id="类的命名">类的命名</h3>
<ul>
<li class="fragment"><p>类名一般使用驼峰命名法, CapWords</p></li>
<li class="fragment"><p>某些情况下, 类被当作callable使用, 这时适用于函数命名规范</p></li>
<li class="fragment"><p>builtin名称是特例, 大部分的builtin名是一个小写单词(或两个词连一起), 除了</p></li>
<li class="fragment"><p>异常和常量是使用驼峰命名</p></li>
</ul>
<pre class="python"><code>&gt;&gt;&gt; import __builtin__
&gt;&gt;&gt; dir(__builtin__)
[&#39;ArithmeticError&#39;, &#39;AssertionError&#39;, &#39;AttributeError&#39;, &#39;BaseException&#39;, &#39;BufferError&#39;, &#39;BytesWarning&#39;, &#39;DeprecationWarning&#39;, &#39;EOFError&#39;, &#39;Ellipsis&#39;, &#39;EnvironmentError&#39;, &#39;Exception&#39;, &#39;False&#39;, &#39;FloatingPointError&#39;, &#39;FutureWarning&#39;, &#39;GeneratorExit&#39;, &#39;IOError&#39;, &#39;ImportError&#39;, &#39;ImportWarning&#39;, &#39;IndentationError&#39;, &#39;IndexError&#39;, &#39;KeyError&#39;, &#39;KeyboardInterrupt&#39;, &#39;LookupError&#39;, &#39;MemoryError&#39;, &#39;NameError&#39;, &#39;None&#39;, &#39;NotImplemented&#39;, &#39;NotImplementedError&#39;, &#39;OSError&#39;, &#39;OverflowError&#39;, &#39;PendingDeprecationWarning&#39;, &#39;ReferenceError&#39;, &#39;RuntimeError&#39;, &#39;RuntimeWarning&#39;, &#39;StandardError&#39;, &#39;StopIteration&#39;, &#39;SyntaxError&#39;, &#39;SyntaxWarning&#39;, &#39;SystemError&#39;, &#39;SystemExit&#39;, &#39;TabError&#39;, &#39;True&#39;, &#39;TypeError&#39;, &#39;UnboundLocalError&#39;, &#39;UnicodeDecodeError&#39;, &#39;UnicodeEncodeError&#39;, &#39;UnicodeError&#39;, &#39;UnicodeTranslateError&#39;, &#39;UnicodeWarning&#39;, &#39;UserWarning&#39;, &#39;ValueError&#39;, &#39;Warning&#39;, &#39;ZeroDivisionError&#39;, &#39;__debug__&#39;, &#39;__doc__&#39;, &#39;__import__&#39;, &#39;__name__&#39;, &#39;__package__&#39;, &#39;abs&#39;, &#39;all&#39;, &#39;any&#39;, &#39;apply&#39;, &#39;basestring&#39;, &#39;bin&#39;, &#39;bool&#39;, &#39;buffer&#39;, &#39;bytearray&#39;, &#39;bytes&#39;, &#39;callable&#39;, &#39;chr&#39;, &#39;classmethod&#39;, &#39;cmp&#39;, &#39;coerce&#39;, &#39;compile&#39;, &#39;complex&#39;, &#39;copyright&#39;, &#39;credits&#39;, &#39;delattr&#39;, &#39;dict&#39;, &#39;dir&#39;, &#39;divmod&#39;, &#39;enumerate&#39;, &#39;eval&#39;, &#39;execfile&#39;, &#39;exit&#39;, &#39;file&#39;, &#39;filter&#39;, &#39;float&#39;, &#39;format&#39;, &#39;frozenset&#39;, &#39;getattr&#39;, &#39;globals&#39;, &#39;hasattr&#39;, &#39;hash&#39;, &#39;help&#39;, &#39;hex&#39;, &#39;id&#39;, &#39;input&#39;, &#39;int&#39;, &#39;intern&#39;, &#39;isinstance&#39;, &#39;issubclass&#39;, &#39;iter&#39;, &#39;len&#39;, &#39;license&#39;, &#39;list&#39;, &#39;locals&#39;, &#39;long&#39;, &#39;map&#39;, &#39;max&#39;, &#39;memoryview&#39;, &#39;min&#39;, &#39;next&#39;, &#39;object&#39;, &#39;oct&#39;, &#39;open&#39;, &#39;ord&#39;, &#39;pow&#39;, &#39;print&#39;, &#39;property&#39;, &#39;quit&#39;, &#39;range&#39;, &#39;raw_input&#39;, &#39;reduce&#39;, &#39;reload&#39;, &#39;repr&#39;, &#39;reversed&#39;, &#39;round&#39;, &#39;set&#39;, &#39;setattr&#39;, &#39;slice&#39;, &#39;sorted&#39;, &#39;staticmethod&#39;, &#39;str&#39;, &#39;sum&#39;, &#39;super&#39;, &#39;tuple&#39;, &#39;type&#39;, &#39;unichr&#39;, &#39;unicode&#39;, &#39;vars&#39;, &#39;xrange&#39;, &#39;zip&#39;]</code></pre>
</section><section class="slide level2">

<h3 id="异常的命名">异常的命名</h3>
<ul>
<li class="fragment"><p>因为异常是类, 所以应该遵从类的命名规范, 使用驼峰法</p></li>
<li class="fragment"><p>一般异常类名后缀以 <code>Error</code> 结尾</p></li>
</ul>
</section><section class="slide level2">

<h3 id="全局变量的命名">全局变量的命名</h3>
<ul>
<li class="fragment"><p>全局变量指的就是模块级别的变量</p></li>
<li class="fragment"><p>全局变量的命名规范和函数一样</p></li>
<li class="fragment"><p>如果模块被设计来通过 <code>import *</code> 暴露其中的名称, 则应该使用 <code>__all__</code> 机制, 或者使用下划线开头的名称</p></li>
</ul>
</section><section class="slide level2">

<h3 id="函数的命名">函数的命名</h3>
<ul>
<li class="fragment"><p>函数名应该是小写</p></li>
<li class="fragment"><p>单词之间使用下划线分隔以提高可读性</p></li>
<li class="fragment"><p>为了向后兼容, 也可以使用 mixedCase 风格, 保持上下文的一致性</p></li>
</ul>
</section><section class="slide level2">

<h3 id="函数和方法的参数命名">函数和方法的参数命名</h3>
<ul>
<li class="fragment"><p>参数名应该是小写</p></li>
<li class="fragment"><p>单词之间使用下划线分隔以提高可读性</p></li>
<li class="fragment"><p>实例方法的第一个参数名总是 <code>self</code></p></li>
<li class="fragment"><p>类方法的第一个参数名总是 <code>cls</code></p></li>
<li class="fragment"><p>如果参数名和Python关键字冲突, 一般的做法是加一个下划线做后缀(或者找个同义词)</p></li>
</ul>
</section><section class="slide level2">

<h3 id="方法的命名和实例变量">方法的命名和实例变量</h3>
<ul>
<li class="fragment"><p>和函数的命名规范一致</p></li>
<li class="fragment"><p>使用下划线前缀来标示 non-public</p></li>
<li class="fragment"><p>如果要避免和子类发生命名冲突, 使用双下划线前缀</p></li>
</ul>
</section><section class="slide level2">

<h3 id="常量的命名">常量的命名</h3>
<ul>
<li class="fragment"><p>常量的作用范围一般定义为模块级别</p></li>
<li class="fragment"><p>使用全大写字母, 中间用下划线隔开, 如 <code>MAX_LENGTH</code></p></li>
</ul>
</section><section id="关于继承的设计" class="slide level2">
<h1>关于继承的设计</h1>
<ul>
<li class="fragment"><p>想清楚类/实例的方法或变量是public还是non-public</p></li>
<li class="fragment"><p>如果有疑惑, 选择non-public, 这样以后转为public也更容易</p></li>
<li class="fragment"><p>non-public 不等同于其他语言的 <code>private</code>, 实际上Python中没有真正意义上的private</p></li>
</ul>
</section><section class="slide level2">

<h3 id="一些pythonic的建议">一些Pythonic的建议</h3>
<ul>
<li class="fragment"><p>Public 属性没有下划线前缀</p></li>
<li class="fragment"><p>如果 public 属性名和关键字冲突, 使用下划线后缀</p></li>
<li class="fragment"><p>使用property, 尽量保证函数式行为</p></li>
<li class="fragment"><p>如果类被设计为基类, 但是不想其中的属性被继承, 使用双下划线前缀</p></li>
</ul>
</section><section id="外部和内部接口" class="slide level2">
<h1>外部和内部接口</h1>
</section></section>
<section><section id="编码建议" class="titleslide slide level1"><h1>编码建议</h1></section><section id="编写与python实现无关的代码" class="slide level2">
<h1>编写与Python实现无关的代码</h1>
<ul>
<li class="fragment"><p>Python有多种实现(PyPy, Jython, IronPython, Cython, Psyco等等)</p></li>
<li class="fragment"><p>不要编写在某种特定实现下比较高效的代码</p>
<p>例如: CPython实现中的字符串就地拼接(<code>a += b</code> 或 <code>a = a + b</code>)比较高效, 然而这种优化是不可靠的, 出于性能的考虑, 应该使用标准库的 <code>''.join()</code> 方法.</p></li>
</ul>
</section><section id="单体的比较" class="slide level2">
<h1>单体的比较</h1>
<ul>
<li class="fragment"><p>单体(singletons), 如 <code>None</code> 的比较使用 <code>is</code> 和 <code>is not</code>, 而不是 <code>==</code></p></li>
<li class="fragment"><p>在 <code>if</code> 语句中注意 <code>if x</code> 和 <code>if x is not None</code> 的区别.</p></li>
</ul>
<div class="fragment">
<pre class="python"><code>x = None

def count(x):
    if x:
        return len(x)
    else:
        return 0

def init(x):
    if x is None:
        x = []</code></pre>
</div>
</section><section class="slide level2">

<p>使用 <code>is not</code>, 而不是 <code>not ... is</code></p>
<pre class="python"><code># Yes:
if foo is not None:

# No:
if not foo is None:</code></pre>
</section><section id="rich-comparisons" class="slide level2">
<h1>Rich Comparisons</h1>
<ul>
<li class="fragment"><p>要实现丰富比较, 最好一次性实现6种操作 (<code>__eq__ , __ne__ , __lt__ , __le__ , __gt__ , __ge__</code>)</p></li>
<li class="fragment"><p><code>functools.total_ordering()</code> 可以帮助简化实现</p></li>
<li class="fragment"><p>Python假定操作是自反的, 例如, 解释器有可能会将 <code>x &lt; y</code> 调换为 <code>x &gt; y</code></p></li>
</ul>
</section><section id="lambda赋值" class="slide level2">
<h1>lambda赋值</h1>
<ul>
<li class="fragment"><p>避免使用 <code>lamda</code> 语句赋值给函数对象</p></li>
<li class="fragment"><p><code>lamda</code> 语句相对于 <code>def</code> 语句的优势是可以嵌入在一个长表达式中, 使用了赋值实际上就消除了这一点</p></li>
</ul>
<div class="fragment">
<pre class="python"><code># Yes:
def f(x): return 2*x

# No:
f = lambda x: 2*x</code></pre>
</div>
</section><section id="派生异常类" class="slide level2">
<h1>派生异常类</h1>
<ul>
<li class="fragment"><p>定义异常派生类时, 选择 <code>Exception</code> 作为基类, 而不是 <code>BaseException</code></p></li>
<li class="fragment"><p>Aim to answer the question &quot;What went wrong?&quot; programmatically, rather than only stating that &quot;A problem occurred&quot;</p></li>
<li class="fragment"><p>遵从类的命名规范, 一般会带上Error后缀, 当然有些异常不算是错误的话, 也可以省略</p></li>
</ul>
</section><section id="异常链" class="slide level2">
<h1>异常链</h1>
<ul>
<li class="fragment"><p>Python3中需要使用 <code>raise X from Y</code> 来显式的表明异常替换, 保留完整的traceback</p></li>
<li class="fragment"><p>如果确实要替换异常, 使用 <code>raise X</code> in Python2, <code>raise X from None</code> in Python 3.3+</p></li>
<li class="fragment"><p>如果要替换抛出的异常, 一般要确保把前一个异常的详细信息保留下来</p></li>
</ul>
</section><section id="抛异常" class="slide level2">
<h1>抛异常</h1>
<ul>
<li class="fragment"><p>Python2中, 使用 <code>raise ValueError('message')</code>, 而不是 <code>raise ValueError, 'message'</code></p></li>
<li class="fragment"><p>后者的语法在Python3中已经淘汰</p></li>
</ul>
</section><section id="捕获异常" class="slide level2">
<h1>捕获异常</h1>
<ul>
<li class="fragment"><p>当捕获异常时, 尽量指明特定的异常类型, 而不是空的 <code>except:</code> 语句</p></li>
<li class="fragment"><p>空 <code>except:</code> 会同时捕获 <code>SystemExit</code> 和 <code>KeyboardInterrupt</code>, 使得程序难以用 Ctrl-C停止, 同时掩盖其它异常</p></li>
<li class="fragment"><p>如果想捕获所有异常, 使用 <code>except Exception:</code></p></li>
<li class="fragment"><p><code>except:</code> 等同于 <code>except BaseException:</code></p></li>
</ul>
<pre class="python"><code>try:
    import platform_specific_module
except ImportError:
    platform_specific_module = None</code></pre>
</section><section class="slide level2">

<ul>
<li class="fragment">需要绑定捕获到的异常时, 使用如下的语法:</li>
</ul>
<pre class="python"><code>try:
    process_data()
except Exception as exc:
    raise DataProcessingFailedError(str(exc))</code></pre>
<ul>
<li class="fragment">下面Python2中老式的逗号分隔的语法在Python3中已经废弃</li>
</ul>
<pre class="python"><code>try:
    process_data()
except Exception, exc:
    raise DataProcessingFailedError(str(exc))</code></pre>
</section><section class="slide level2">

<p>When catching operating system errors, prefer the explicit exception hierarchy introduced in Python 3.3 over introspection of <code>errno</code> values.</p>
</section><section class="slide level2">

<ul>
<li class="fragment">对 <code>try/except</code> 语句, 限制 <code>try</code> 子句覆盖的代码必要范围, 有助于避免隐藏bug.</li>
</ul>
<pre class="python"><code># Yes:
try:
    value = collection[key]
except KeyError:
    return key_not_found(key)
else:
    return handle_value(value)

# No:
try:
    # Too broad!
    return handle_value(collection[key])
except KeyError:
    # Will also catch KeyError raised by handle_value()
    return key_not_found(key)</code></pre>
</section><section id="return语句" class="slide level2">
<h1>return语句</h1>
<ul>
<li class="fragment">保证return的一致性, 要么一个函数中的所有return都有表达式返回, 要么都没有</li>
<li class="fragment">如果任何一个return有表达式返回, 其它没有值返回的return语句也应该显式 <code>return None</code></li>
<li class="fragment">函数的结尾应该有个显式的return</li>
</ul>
</section><section class="slide level2">

<p>Yes</p>
<pre class="python"><code>def foo(x):
    if x &gt;= 0:
        return math.sqrt(x)
    else:
        return None

def bar(x):
    if x &lt; 0:
        return None
    return math.sqrt(x)</code></pre>
<p>No</p>
<pre class="python"><code>def foo(x):
    if x &gt;= 0:
        return math.sqrt(x)

def bar(x):
    if x &lt; 0:
        return
    return math.sqrt(x)</code></pre>
</section><section id="字符串" class="slide level2">
<h1>字符串</h1>
<ul>
<li class="fragment"><p>优先使用字符串方法(methods)代替字符串模块, 字符串方法总是很快, 而且和unicode字符串共用同样的API</p></li>
<li class="fragment"><p>检查前缀和后缀时避免使用切片的方式, 而是使用 <code>startswith()</code> 和 <code>endswith()</code>, 表达更清晰而且不容易出错</p></li>
</ul>
<pre class="python"><code>Yes: if foo.startswith(&#39;bar&#39;):
No:  if foo[:3] == &#39;bar&#39;:</code></pre>
</section><section class="slide level2">

<ul>
<li class="fragment">格式化字符串使用 <code>%</code> 操作符或者 <code>format</code> 方法</li>
<li class="fragment">如果参数都是字符串, 比较简单的情况下, 则使用 <code>+</code> 更清楚</li>
</ul>
<div class="fragment">
<pre class="python"><code># Yes: 
x = a + b
x = &#39;%s, %s!&#39; % (imperative, expletive)
x = &#39;{}, {}!&#39;.format(imperative, expletive)
x = &#39;name: %s; score: %d&#39; % (name, n)
x = &#39;name: {}; score: {}&#39;.format(name, n)

# No: 
x = &#39;%s%s&#39; % (a, b)  # use + in this case
x = &#39;{}{}&#39;.format(a, b)  # use + in this case
x = imperative + &#39;, &#39; + expletive + &#39;!&#39;
x = &#39;name: &#39; + name + &#39;; score: &#39; + str(n)</code></pre>
</div>
</section><section class="slide level2">

<ul>
<li class="fragment">避免在循环中使用 <code>+</code> 和 <code>+=</code> 累加字符串</li>
<li class="fragment">使用列表保存子串, 最后使用 <code>.join</code> 连接</li>
</ul>
<div class="fragment">
<pre class="python"><code># Yes: 
items = [&#39;&lt;table&gt;&#39;]
for last_name, first_name in employee_list:
    items.append(&#39;&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;&#39; % (last_name, first_name))
items.append(&#39;&lt;/table&gt;&#39;)
employee_table = &#39;&#39;.join(items)

# No: 
employee_table = &#39;&lt;table&gt;&#39;
for last_name, first_name in employee_list:
    employee_table += &#39;&lt;tr&gt;&lt;td&gt;%s, %s&lt;/td&gt;&lt;/tr&gt;&#39; % (last_name, first_name)
employee_table += &#39;&lt;/table&gt;&#39;</code></pre>
</div>
</section><section class="slide level2">

<ul>
<li class="fragment">在同一个文件中, 保持字符串引号的一致性, 即要么都是单引号,要么都是双引号; 当然字符串内可以使用另一种引号</li>
<li class="fragment">优先使用三重双引号(<code>&quot;&quot;&quot;</code>)而不是三重单引号(<code>'''</code>)</li>
<li class="fragment">三重引号一般就用于docstrings, 普通情况下多行字符串应该使用隐式行连接</li>
</ul>
<div class="fragment">
<pre class="python"><code># No:
def log():
    print &quot;&quot;&quot;This is pretty ugly.
Don&#39;t do this.
&quot;&quot;&quot;

# Yes:
def report():
    print (&quot;This is much nicer.\n&quot;
           &quot;Do it this way.\n&quot;)</code></pre>
</div>
</section><section id="类型判断" class="slide level2">
<h1>类型判断</h1>
<ul>
<li class="fragment">总是使用 <code>isinstance()</code> 方法而不是直接比较对象的类型</li>
</ul>
<div class="fragment">
<pre class="python"><code># Yes: 
if isinstance(obj, int):

# No:  
if type(obj) is type(1):</code></pre>
<ul>
<li class="fragment">当判断一个对象是否字符串类型时, 记住它还有可能是unicode!, Python2中 <code>str</code> 和 <code>unicode</code> 有相同的基类 <code>basestring</code>, 所以:</li>
<li class="fragment">Python 3中, 只有 <code>str</code> 类型</li>
</ul>
<pre class="python"><code># for python 2.x
if isinstance(obj, basestring):</code></pre>
</div>
</section><section id="bool判断" class="slide level2">
<h1>bool判断</h1>
<ul>
<li class="fragment">对于序列对象(如字符串,列表,元组), 记住空序列的结果就是 <code>False</code></li>
</ul>
<pre class="python"><code># Yes: 
if not seq:
if seq:

# No: 
if len(seq):
if not len(seq):</code></pre>
<ul>
<li class="fragment">不要将对象和 <code>Ture</code> 或 <code>False</code> 使用 <code>==</code> 比较</li>
</ul>
<pre class="python"><code>Yes:   if greeting:
No:    if greeting == True:
Worse: if greeting is True:</code></pre>
</section></section>
<section><section id="惯用法" class="titleslide slide level1"><h1>惯用法</h1></section><section id="be-pythonic" class="slide level2">
<h1>Be Pythonic</h1>
<p>下面主要介绍Python语言中的惯用法.</p>
<p>多多应用这些惯用写法, 就能把Python代码写的如人们常说的那样更加Pythonic.</p>
</section><section class="slide level2">

<h3 id="交换变量的值">交换变量的值</h3>
<pre class="python"><code>temp = a
a = b
b = temp</code></pre>
<pre class="python"><code>a, b = b, a</code></pre>
</section><section class="slide level2">

<p>How it works?</p>
<ul>
<li class="fragment">逗号是元组的构造语法</li>
<li class="fragment">右边创建一个元组(打包 packing)</li>
<li class="fragment">左边是目标元组(解包 unpacking)</li>
</ul>
<div class="fragment">
<p>函数有多个返回值时也用到这种语法</p>
<pre class="python"><code>def person():
    return &quot;bob&quot;, 18

name, age = person()</code></pre>
</div>
</section><section class="slide level2">

<h3 id="链式比较">链式比较</h3>
<pre class="python"><code>if b &gt;= 1 and b &lt;= a and a &lt; 10:
    pass</code></pre>
<pre class="python"><code>if 1 &lt;= b &lt;= a &lt; 10:
    pass</code></pre>
</section><section class="slide level2">

<h3 id="使用in">使用in</h3>
<p>以下两种写法有何区别:</p>
<pre class="python"><code>for key in d:
    print key</code></pre>
<pre class="python"><code>for key in d.keys():
    print key</code></pre>
</section><section class="slide level2">

<p>判断字典中是否包含key:</p>
<pre class="python"><code># do this:
if key in d:
    print d[key]</code></pre>
<pre class="python"><code># not this:
if d.has_key(key):
    print d[key]</code></pre>
</section><section class="slide level2">

<h3 id="获取字典值">获取字典值</h3>
<p>使用 <code>dict.get</code> 来尝试获取字典值并指定默认值</p>
<pre class="python"><code>d = {&#39;age&#39;: 23, &#39;workage&#39;: 1, &#39;name&#39;: &#39;Tim&#39;}
if &#39;workage&#39; in d:
    d[&#39;workage&#39;] += 1
else:
    d[&#39;workage&#39;] = 1</code></pre>
<pre class="python"><code>d = {&#39;name&#39;: &#39;Tim&#39;, &#39;age&#39;: 23}  
d[&#39;workage&#39;] = d.get(&#39;workage&#39;, 0) + 1</code></pre>
</section><section class="slide level2">

<h3 id="字典设置缺省值">字典设置缺省值</h3>
<p>使用 <code>dict.setdefault</code> 高效的为字典设置缺省值.</p>
<p>例如: 假设存在一组数据data, 每一条数据前面是某个项目的名称, 后面是该项目的值</p>
<pre class="python"><code>data = [(&#39;A&#39;, 3), (&#39;B&#39;, 5), (&#39;B&#39;, 8), (&#39;A&#39;, 20), (&#39;C&#39;, 10)]</code></pre>
<ol type="1">
<li class="fragment">将每一项的所有值汇总为一个列表</li>
</ol>
<pre class="python"><code>results = {}
for name, count in data:
    results.setdefault(name, []).append(count)</code></pre>
<ol start="2" type="1">
<li class="fragment">将每一项的所有值求和</li>
</ol>
<pre class="python"><code>results = {}
for name, count in data:
    results.setdefault(name, 0)  
    results[name] += count</code></pre>
</section><section class="slide level2">

<h3 id="列表解析">列表解析</h3>
<p>基于一个列表(或其它序列)生成新的列表时, 尽量使用列表解析.</p>
<pre class="python"><code>new_list = []
for item in a_list:
    if condition(item):
        new_list.append(fn(item))</code></pre>
<pre class="python"><code>new_list = [fn(item) for item in a_list if condition(item)]</code></pre>
</section><section class="slide level2">

<h3 id="生成器表达式">生成器表达式</h3>
<p>先看一个例子: 计算 1-100 的平方和.</p>
<div class="fragment">
<p>普通循环</p>
<pre class="python"><code>total = 0
for num in range(1, 101):
    total += num * num</code></pre>
<p>列表解析</p>
<pre class="python"><code>total = sum([num * num for num in range(1, 101)])</code></pre>
<p>生成器表达式</p>
<pre class="python"><code>total = sum(num * num for num in xrange(1, 101))</code></pre>
</div>
</section><section class="slide level2">

<h3 id="for...else...">for...else...</h3>
<p><code>for</code> 循环可以使用 <code>else</code> 子句来处理没有从for循环中断的情况</p>
<pre class="python"><code>find = False
for x in xrange(1,5):
    if x == 5:
        find = True
        print &#39;find 5&#39;
        break
if not find:
    print &#39;can not find 5!&#39;</code></pre>
<pre class="python"><code>for x in xrange(1,5):
    if x == 5:
        print &#39;find 5&#39;
        break
else:
    print &#39;can not find 5!&#39;</code></pre>
</section><section class="slide level2">

<h3 id="三元操作符">三元操作符</h3>
<p>有C语言经验的可能会想念 <code>A ? B : C</code> 这种三元操作符</p>
<pre class="c"><code>int a = x ? 1 : 0 </code></pre>
<pre class="python"><code>if x &gt; 2:
    a = 1
else:
    a = 0</code></pre>
<pre class="python"><code>a = 1 if x &gt; 2 else 0</code></pre>
</section><section class="slide level2">

<h3 id="枚举">枚举</h3>
<p>使用enumerate可以一次性将索引和值取出，避免使用索引来取值</p>
<pre class="python"><code>array = [1, 2, 3, 4, 5]
for i in xrange(len(array)):
    print i, array[i]</code></pre>
<pre class="python"><code>array = [1, 2, 3, 4, 5]
for i, e in enumerate(array,0):
    print i, e</code></pre>
</section><section class="slide level2">

<h3 id="模块or脚本">模块or脚本</h3>
<p>一个 <code>.py</code> 文件既可以作为Python模块, 也可以当做是一个脚本来执行.</p>
<p>一般情况下是在文件的最后加上:</p>
<pre class="python"><code>if __name__ == &#39;__main__&#39;:
    # script code here</code></pre>
<ul>
<li class="fragment">其中使用特殊变量 <code>__name__</code>,</li>
<li class="fragment">如果该文件是被import, 则 <code>__name__</code> 值为该模块名称(即不带<code>.py</code>的文件名)</li>
<li class="fragment">如果该文件被当做脚本执行, 则 <code>__name__</code> 值为 <code>__main__</code>, 所以 <code>if</code> 语句下面的内容会被执行</li>
</ul>
</section><section class="slide level2">

</section></section>
<section><section id="作业" class="titleslide slide level1"><h1>作业</h1></section><section id="作业1" class="slide level2">
<h1>作业1</h1>
<p>根据PEP8中的代码规范检查自己编写的python代码, 根据情况修改其中不符合的地方.</p>
<p>自测方法是在PyCharm中打开代码, IDE自动检测.</p>
</section><section id="作业2" class="slide level2">
<h1>作业2</h1>
<p>计算一个数是否&quot;happy&quot;.</p>
<p>Happy数的定义如下:</p>
<ol type="1">
<li>首先给定一个正整数 number</li>
<li>对该正整数的每一位求平方和, 得到新的正整数</li>
<li>重复步骤2, 直到最终结果为1, 或者陷入无限循环</li>
<li>如果最终的结果能达到1, 表示 number 是happy的</li>
</ol>
<p>例如: 19 是happy数, 因为:</p>
<pre><code>1*1 + 9*9 = 82
8*8 + 2*2 = 68
6*6 + 8*8 = 100
1*1 + 0*0 + 0*0 = 1</code></pre>
</section><section class="slide level2">

<h3 id="提示">提示</h3>
<ol type="1">
<li class="fragment">需要记录已经出现过的数字</li>
</ol>
<p>问题来源: https://leetcode.com/problems/happy-number/</p>
</section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
          { src: 'reveal.js/plugin/notes/notes.js', async: true },
          { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
      });
    </script>
    </body>
</html>
